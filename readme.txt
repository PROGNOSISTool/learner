Hello. Here you have the learner, mapper and learner configuration. A general scheme of the tools:

Learner  -  Mapper     -    Local Boundary    -Pkt crafter-  Network Boundary - Listening Server  
------------------------                      -------------                   -------------   
		 -	Abs -> Conc-   Concrete String    -           -   TCP Request     -           -
LearnLib -  <-----------   <------------>-    -  Adapter    <-------------->  -  Server   -   
		 -	Abs <- Conc-      Messages        -           -   TCP Response    -           -
------------------------      -				  -------------                   -------------
To learn, 
-> start the server: (TCPListenerMain.java or any server implementation of your choice)
-> start the network adapter
-> start the learner setup 

In the setup I have used I had:
the server running on my host OS (Windows 8)
the network adapter and learning setup running on a Ubuntu VM
On my host OS I ran Wireshark, in order to monitor the TCP packets sent/received. 

Do use Ubuntu for the adapter/server, since scapy was not meant to be run on Windows and cygwin sux. Never use cygwin and NO, a tool that needs cygwin in order
to run on Windows is NOT portable.

The learner tool
The learning setup is based on the setup used for the Testing Techniques assignments, but it is specifically tailored for learning TCP. (So do not try to learn 
Candy Machines with it). It creates concrete input requests and reads out concrete outputs responses from a socket (at the other end of which is the adapter) and
attempts to learn the system. It also abstracts these requests and responses through the Mapper component.

The interesting components are:
src/sut.interfacing.* where you can find
-> Mapper.java the implementation of the mapper component that does the abstraction/concretization
-> SutSocketWrapper.java contains TIMEOUT and UNDEFINED handling (for the most part, not handled by the mapper) and also implements communication with the SUT.
-> TraceLogger.java - a logger component used to log all traces, as well as interesting traces
src/abslearning.learner.*
-> Main.java stores the main function that you need to run.
input/tcp
-> configuration files for the learner, sutinfo.yaml defines the system interface
output/ 
-> here you'll see all your outputs every time you learn a system
traceFiles
-> here are logs for the traces, both interesting and not

A trace is deemed interesting if on a request, one of the SEQ or ACK predictions in the response yields INV. 
This should tell the user that the conditions implemented in the mapper are not output predicting. In the context of this setup, the mapper is output predicting
if both SYN and ACK numbers from concrete responses are abstracted to VALID outputs to the learner. 

The goal is to, whenever possible, predict via conditions in the mapper the concrete output. It is not always possible to do so, for example, it is not possible in the
case of the first SYN number generated by the server, but in other cases it is. The stronger/more restrictive the output prediction is, the better. For example,
a VALID abstraction given whenever SYN and ACK numbers given as response are smaller than 2 ^ 32 is weak and not useful. In contrast, a prediction implying 
the response ACK is is always equal to the request ACK + 1 is much stronger. It is much more difficult to come up with strong predictions.

Running the TCP Learner tool:
-> import NetworkSetup as a project in eclipse
-> Run -> Run Configurations -> 
Main Class: abslearning.learner.Main
Project: NetworkSetup
Arguments: --port 18201 your_path/NetworkSetup/input/tcp/config.yaml
Configure learning parameters in /input/tcp
Before running, make sure that networkAdapter.py and the server (on the other environment) are also running.

You have to synchronize the port argument here with the value given through the -lcp option to the network adapter
ie They have to be the same.  

The python adapter tool
Built on Ramon's implementation, this tool, listens on a local port for request strings, transforms them into real packets, sends them over the network to the
listening server, retrieves the respective response (or a timeout, if there wasn't one), serializes them into strings and sends them writes them to the same local 
port. 
It communicates with
--> the learner locally through the local communication port
--> the server over the network through a network port
Frameworks used: 
scapy -> crafting packets and sending them/retrieving responses
pcapy, impacket -> monitoring the network / intercept packets
Some notes on installing pcapy and impacket can be found in proglogs.txt .
The adapter project comprises of two tools:
--> networkAdapter.py , the main tool that you need to run
--> traceRunner.py : executes a an abstract trace

The network adapter uses scapy to craft packets. For packet interception it uses scapy in tandem with a tracker tool based on pcapy and impacket. 

Running the adapter tool:
after installing: python 2.6/2.7 scapy, pcapy and impacket
On Ubuntu, run the rule that drops all the OS RST responses:
sudo iptables -A OUTPUT -p tcp --tcp-flags RST RST -j DROP
Run the adapter
sudo python networkAdapter.py
You can read on commands through the --help option. 

Running the trace runner tool:
same requirements as with the adapter
sudo python traceRunner.py
Settings are tweaked by changing variables in the file itself.

The listening server:
Listens on a server port. Implemented in Java, but you can build it in any other language. Just make sure the server port matches with the one used by the
adapter/trace runner.

Questions and feedback at:
 P.Fiterau-Brostean@science.ru.nl <P.Fiterau-Brostean@science.ru.nl>;
Cheers!